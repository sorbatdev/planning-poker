<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planning Poker - Agile Estimation Tool</title>
    <meta name="description" content="Free online Planning Poker tool for agile teams. Real-time collaboration for story point estimation.">
    <script src="https://www.gstatic.com/firebasejs/12.1.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/12.1.0/firebase-database-compat.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="app-container">
        <header>
            <h1>Planning Poker</h1>
            <div id="session-info" class="session-info"></div>
        </header>

        <!-- Login/Join Section -->
        <div id="join-form" class="join-form">
            <div class="form-card">
                <h2>Start Your Session</h2>

                <!-- Initial choice buttons -->
                <div id="choice-buttons" class="choice-buttons">
                    <button class="btn btn-primary" onclick="showCreate()">Create New Session</button>
                    <button class="btn btn-secondary" onclick="showJoin()">Join Existing Session</button>
                </div>

                <!-- Create form -->
                <div id="create-form" class="form-fields" style="display:none;">
                    <input id="name-create" class="input-field" placeholder="Your Name" maxlength="9" required>
                    <button class="btn btn-success" onclick="createSession()">Start Session</button>
                    <button class="btn btn-ghost" onclick="goBack()">‚Üê Back</button>
                </div>

                <!-- Join form -->
                <div id="join-fields" class="form-fields" style="display:none;">
                    <input id="name-join" class="input-field" placeholder="Your Name" maxlength="9" required>
                    <input id="session-input" class="input-field" placeholder="Session ID" required>
                    <button class="btn btn-success" onclick="joinSession()">Join Session</button>
                    <button class="btn btn-ghost" onclick="goBack()">‚Üê Back</button>
                </div>
            </div>
        </div>

        <!-- Game Area -->
        <div id="game-area" class="game-area" style="display:none;">
            <!-- Controls -->
            <div id="controls" class="controls">
                <button id="reveal-cards" class="btn btn-reveal" onclick="revealCards()">
                    <span class="btn-icon">üëÅÔ∏è</span> Reveal Cards
                </button>
                <button id="reset-round" class="btn btn-reset" onclick="resetRound()">
                    <span class="btn-icon">üîÑ</span> New Round
                </button>
            </div>

            <!-- Poker Table Area -->
            <div id="table-container" class="table-container">
                <div id="poker-table" class="poker-table">
                    <div class="table-felt">
                        <div id="table-center" class="table-center">
                            <div id="round-status" class="round-status">
                                <span class="status-text">Choose your card</span>
                            </div>
                            <div id="average-display" class="average-display-center"></div>
                        </div>
                    </div>
                </div>
                <div id="user-cards" class="user-cards"></div>
            </div>

            <!-- User List Sidebar -->
            <div id="user-list" class="user-list">
                <h3>Players</h3>
                <div id="user-list-items"></div>
            </div>

            <!-- Card Deck -->
            <div id="card-deck" class="card-deck">
                <div class="deck-container"></div>
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "{{FIREBASE_API_KEY}}",
            authDomain: "{{FIREBASE_AUTH_DOMAIN}}",
            databaseURL: "{{FIREBASE_DATABASE_URL}}",
            projectId: "{{FIREBASE_PROJECT_ID}}",
            storageBucket: "{{FIREBASE_STORAGE_BUCKET}}",
            messagingSenderId: "{{FIREBASE_MESSAGING_SENDER_ID}}",
            appId: "{{FIREBASE_APP_ID}}"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        // ======================================
        //           State Management
        // ======================================
        const state = {
            sessionId: null,
            userId: null,
            userName: null,
            isRevealed: false,
            isHost: false,
            users: {},
            selectedCard: null
        };

        const cardValues = [
            '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '10', '12', '14', '16', '18',
            '20', '22', '24', '26', '28',
            '30', '32', '34', '36', '38',
            '40', '?', '‚òï'
        ];

        const maxPlayers = 10;

        // ======================================
        //           DOM Elements Cache
        // ======================================
        let elements = {}; // Will be initialized when needed

        function initializeElements() {
            elements = {
                joinForm: document.getElementById('join-form'),
                gameArea: document.getElementById('game-area'),
                sessionInfo: document.getElementById('session-info'),
                userCards: document.getElementById('user-cards'),
                userListItems: document.getElementById('user-list-items'),
                averageDisplay: document.getElementById('average-display'),
                roundStatus: document.querySelector('.status-text'),
                deckContainer: document.querySelector('.deck-container'),
                choiceButtons: document.getElementById('choice-buttons'),
                createForm: document.getElementById('create-form'),
                joinFields: document.getElementById('join-fields'),
                revealButton: document.getElementById('reveal-cards'),
                resetButton: document.getElementById('reset-round')
            };
        }

        // ======================================
        //           Utility Functions
        // ======================================
        function generateId(length = 6) {
            return Math.random().toString(36).substring(2, 2 + length).toUpperCase();
        }

        function showCreate() {
            document.getElementById('choice-buttons').style.display = 'none';
            document.getElementById('create-form').style.display = 'flex';
        }

        function showJoin() {
            document.getElementById('choice-buttons').style.display = 'none';
            document.getElementById('join-fields').style.display = 'flex';
        }

        function goBack() {
            document.getElementById('create-form').style.display = 'none';
            document.getElementById('join-fields').style.display = 'none';
            document.getElementById('choice-buttons').style.display = 'flex';
        }

        function getCardColor(value) {
            // Color gradient based on value ranges
            if (value === '?') return '#667eea';
            if (value === '‚òï') return '#6F4E37';

            const num = parseInt(value);
            if (isNaN(num)) return '#3498db';

            // Gradient from green to red based on value
            if (num <= 5) return '#2ecc71';
            if (num <= 10) return '#3498db';
            if (num <= 16) return '#f39c12';
            if (num <= 24) return '#e67e22';
            if (num <= 32) return '#e74c3c';
            return '#9b59b6'; // 34-40
        }

        // ======================================
        //           Session Management
        // ======================================
        function createSession() {
            const name = document.getElementById('name-create')?.value.trim();
            if (!name) {
                showNotification('Please enter your name', 'error');
                return;
            }

            state.userName = name;
            state.sessionId = generateId();
            state.isHost = true;
            joinUser();
        }

        function joinSession() {
            const name = document.getElementById('name-join')?.value.trim();
            const sessionId = document.getElementById('session-input')?.value.trim().toUpperCase();

            if (!name || !sessionId) {
                showNotification('Please enter both name and session ID', 'error');
                return;
            }

            state.userName = name;
            state.sessionId = sessionId;
            joinUser();
        }

        function joinUser() {
            const sessionRef = db.ref('sessions/' + state.sessionId);

            sessionRef.once('value').then(snap => {
                const data = snap.val();

                // Initialize new session
                if (!data) {
                    if (!state.isHost) {
                        showNotification('Session not found', 'error');
                        return;
                    }
                    sessionRef.set({
                        revealed: false,
                        users: {},
                        host: null,
                        createdAt: Date.now()
                    });
                }

                const existingUsers = data?.users || {};

                console.log(existingUsers);

                state.userId = sessionRef.child('users').push().key;

                // Check session capacity
                if (Object.keys(existingUsers).length >= maxPlayers) {
                    showNotification(`Session is full (max ${maxPlayers} players)`, 'error');
                    return;
                }

                console.log(`Session host: ${data?.host}`);
                console.log(`Is host: ${state.isHost}`);
                console.log(`Users length: ${Object.keys(existingUsers).length}`)

                // If there is no-one in the room and the host is not in the room, become the host.
                if (!data?.host || state.isHost || Object.keys(existingUsers).length < 1) {
                    console.log("Updating Host.");
                    sessionRef.update({ host: state.userId });
                }

                // Check for duplicate names
                const existingNames = Object.values(existingUsers).map(u => u.name);
                if (existingNames.includes(state.userName)) {
                    showNotification('This name is already taken in the session', 'error');
                    return;
                }

                // Add user to session
                sessionRef.child('users/' + state.userId).set({
                    name: state.userName,
                    choice: null
                });

                // Set up disconnect handler
                sessionRef.child('users/' + state.userId).onDisconnect().remove();

                // Show game area
                initializeGame();
                listenToSession();
            });
        }

        function initializeGame() {
            if (!elements.joinForm) {
                initializeElements();
            }

            elements.joinForm.style.display = 'none';
            elements.gameArea.style.display = 'flex';
            elements.sessionInfo.innerHTML = `
                <span class="session-id">Session: <strong>${state.sessionId}</strong></span>
                <button class="btn-copy" onclick="copySessionId()">Copy ID</button>
            `;
            setupDeck();
        }

        function copySessionId() {
            navigator.clipboard.writeText(state.sessionId);
            showNotification('Session ID copied!', 'success');
        }

        function showNotification(message, type = 'info') {
            // Simple notification (you can enhance this with a toast library)
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.classList.add('fade-out');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // ======================================
        //           Real-time Updates
        // ======================================
        function listenToSession() {
            // Ensure elements are initialized
            if (!elements.averageDisplay) {
                initializeElements();
            }

            db.ref('sessions/' + state.sessionId).on('value', snap => {
                const data = snap.val();
                if (!data) return;

                if (!(data.host in data.users))
                {
                    data.host = Object.keys(data.users)[0];
                }

                state.isRevealed = data.revealed;
                state.users = data.users || {};
                state.isHost = data.host === state.userId;

                updateControls();
                updateRoundStatus();
                renderUserCards();
                renderUserList(data.host);

                if (state.isRevealed && data.average) {
                    elements.averageDisplay.style.display = 'block';
                    elements.averageDisplay.innerHTML = `
                        <div class="average-value">${data.average}</div>
                        <div class="average-label">Average</div>
                    `;
                } else {
                    elements.averageDisplay.style.display = 'none';
                    elements.averageDisplay.innerHTML = '';
                }
            });
        }

        function updateControls() {
            if (!elements.revealButton) return;

            elements.revealButton.disabled = !state.isHost;
            elements.resetButton.disabled = !state.isHost;

            if (!state.isHost) {
                elements.revealButton.title = 'Only the host can reveal cards';
                elements.resetButton.title = 'Only the host can reset the round';
            }
        }

        function updateRoundStatus() {
            if (!elements.roundStatus) return;

            const totalUsers = Object.keys(state.users).length;
            const usersVoted = Object.values(state.users).filter(u => u.choice).length;

            if (state.isRevealed) {
                elements.roundStatus.textContent = 'Cards Revealed!';
            } else if (usersVoted === 0) {
                elements.roundStatus.textContent = 'Waiting for votes...';
            } else if (usersVoted === totalUsers) {
                elements.roundStatus.textContent = 'All players have voted!';
            } else {
                elements.roundStatus.textContent = `${usersVoted}/${totalUsers} voted`;
            }
        }

        // ======================================
        //           Card Rendering
        // ======================================
        function renderUserCards() {
            if (!elements.userCards) return;

            elements.userCards.innerHTML = '';
            const userList = Object.entries(state.users);
            const totalUsers = userList.length;

            userList.forEach(([uid, user], index) => {
                // Assuming table dimensions from CSS
                const tableWidth = 600;
                const tableHeight = 400;

                // Your original radius (adjusted for elliptical shape)
                const radiusY = 200; // This acts as the semi-minor axis (vertical radius)

                // Calculate the aspect ratio of the table (width / height)
                const aspectRatio = tableWidth / tableHeight;

                // Derive the semi-major axis (horizontal radius) to maintain the elliptical proportions
                const radiusX = radiusY * aspectRatio;

                // For each user (index from 0 to totalUsers - 1)
                const angle = (index * (360 / totalUsers)) - 90; // In degrees, starting from top
                const rad = angle * Math.PI / 180; // Convert to radians

                // Parametric equations for ellipse
                const x = (radiusX * Math.cos(rad)) - 33;
                const y = (radiusY * Math.sin(rad)) - 33;

                const cardWrapper = document.createElement('div');
                cardWrapper.className = 'user-card-wrapper';
                cardWrapper.style.transform = `translate(${x}px, ${y}px)`;

                // User name
                const userName = document.createElement('div');
                userName.className = 'user-name';
                userName.textContent = user.name;
                if (uid === state.userId) {
                    userName.classList.add('current-user');
                }

                // Card
                const card = document.createElement('div');
                card.className = 'player-card';

                if (!user.choice) {
                    card.classList.add('waiting');
                    card.innerHTML = '<div class="card-back">üé¥</div>';
                } else if (!state.isRevealed) {
                    card.classList.add('selected');
                    card.innerHTML = '<div class="card-back">‚úì</div>';
                } else {
                    card.classList.add('revealed');
                    const color = getCardColor(user.choice);
                    card.style.background = color;
                    card.innerHTML = `<div class="card-value">${user.choice}</div>`;
                }

                cardWrapper.appendChild(card);
                cardWrapper.appendChild(userName);
                elements.userCards.appendChild(cardWrapper);
            });
        }

        function renderUserList(hostId) {
            if (!elements.userListItems) return;

            elements.userListItems.innerHTML = '';

            Object.entries(state.users).forEach(([uid, user]) => {
                const listItem = document.createElement('div');
                listItem.className = 'user-list-item';

                if (uid === state.userId) {
                    listItem.classList.add('current-user');
                }

                const statusIcon = user.choice ? '‚úì' : '‚è≥';
                const hostBadge = uid === hostId ? ' üëë' : '';

                listItem.innerHTML = `
                    <span class="user-status ${user.choice ? 'voted' : 'waiting'}">${statusIcon}</span>
                    <span class="user-name">${user.name}${hostBadge}</span>
                    ${state.isHost && uid !== state.userId ? `
                        <button class="btn-make-host" onclick="transferHost('${uid}')">
                            Make Host
                        </button>
                    ` : ''}
                `;

                elements.userListItems.appendChild(listItem);
            });
        }

        // ======================================
        //           Deck Setup
        // ======================================
        function setupDeck() {
            if (!elements.deckContainer) {
                initializeElements();
            }

            elements.deckContainer.innerHTML = '';

            cardValues.forEach(value => {
                const card = document.createElement('div');
                card.className = 'deck-card';
                card.dataset.value = value;

                const color = getCardColor(value);
                card.style.background = color;

                card.innerHTML = `<span class="card-value">${value}</span>`;
                card.onclick = () => selectCard(value);

                elements.deckContainer.appendChild(card);
            });
        }

        function selectCard(value) {
            if (state.isRevealed) {
                showNotification('Wait for the next round to vote', 'warning');
                return;
            }

            // Update UI
            document.querySelectorAll('.deck-card').forEach(card => {
                card.classList.remove('selected');
            });

            const selectedCard = document.querySelector(`.deck-card[data-value="${value}"]`);
            if (selectedCard) {
                selectedCard.classList.add('selected');
            }

            state.selectedCard = value;

            // Update database
            db.ref(`sessions/${state.sessionId}/users/${state.userId}`).update({
                choice: value
            });
        }

        // ======================================
        //           Host Actions
        // ======================================
        function transferHost(newHostId) {
            if (!state.isHost) return;

            db.ref('sessions/' + state.sessionId).update({ host: newHostId });
            showNotification('Host transferred successfully', 'success');
        }

        function revealCards() {
            if (!state.isHost) {
                showNotification('Only the host can reveal cards', 'warning');
                return;
            }

            const choices = Object.values(state.users)
                .map(user => user.choice)
                .filter(choice => choice);

            const average = calculateAverage(choices);

            db.ref('sessions/' + state.sessionId).update({
                revealed: true,
                average: average
            });
        }

        function resetRound() {
            if (!state.isHost) {
                showNotification('Only the host can reset the round', 'warning');
                return;
            }

            const updates = { revealed: false, average: null };
            Object.keys(state.users).forEach(uid => {
                updates[`users/${uid}/choice`] = null;
            });

            db.ref('sessions/' + state.sessionId).update(updates);

            // Clear selected card in UI
            document.querySelectorAll('.deck-card').forEach(card => {
                card.classList.remove('selected');
            });
            state.selectedCard = null;
        }

        function calculateAverage(choices) {
            const numericValues = choices
                .filter(choice => !isNaN(parseFloat(choice)) && choice !== '?' && choice !== '‚òï')
                .map(choice => parseFloat(choice));

            if (numericValues.length === 0) return 'N/A';

            const avg = numericValues.reduce((sum, val) => sum + val, 0) / numericValues.length;
            return avg.toFixed(1);
        }

        // ======================================
        //           Keyboard Shortcuts
        // ======================================
        document.addEventListener('keydown', (e) => {
            if (state.isHost && e.key === 'r' && e.ctrlKey) {
                e.preventDefault();
                revealCards();
            }
            if (state.isHost && e.key === 'n' && e.ctrlKey) {
                e.preventDefault();
                resetRound();
            }
        });
    </script>
</body>

</html>
